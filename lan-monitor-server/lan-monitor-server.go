package main

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"os/exec"
	"path"
	"strconv"
	"sync"
	"time"

	xj "github.com/basgys/goxml2json"
	"github.com/gorilla/websocket"
)

//VERSION of the program
var version = "undefined-autogenerated"

//gobal variable to store all websocket connections for the update
var cons = make(map[*websocket.Conn]bool)

//mutex to lock the NMAP JSON information
var lock = sync.RWMutex{}

var nmapJSON *bytes.Buffer

//just for development
type msg struct {
	Command string
	Num     int
}

//Config data struct to read the config file
type Config struct {
	NMAPRange    string `json:"nmap_range,omitempty"`
	NMAPPorts    string `json:"nmap_ports,omitempty"` //comma separated
	HTTPPort     int    `json:"http_port,omitempty"`
	ScanInterval int    `json:"scan_interval,omitempty"` //seconds
}

func echo(conn *websocket.Conn) {
	for {
		m := msg{}
		err := conn.ReadJSON(&m)
		if err != nil {
			log.Println("Error reading json.", err)
			break
		}
		lock.RLock()
		if nmapJSON != nil {
			err := conn.WriteMessage(1, nmapJSON.Bytes())
			if err != nil {
				log.Println(err)
				break
			}
		}
		lock.RUnlock()
	}
	delete(cons, conn)
	conn.Close()
}

//ReadConfig reads the config file
func readConfig(configfile string) Config {
	var config Config
	data, err := ioutil.ReadFile(configfile)
	if err != nil {
		log.Println("Error opening for JSON parsing - reverting to defaults")
	}

	err = json.Unmarshal(data, &config)
	if err != nil {
		log.Println("Error parsing json config:", err)
		log.Println("Continuing with defaults", err)
	}

	return config
}

func callNMAP(conf Config) {
	log.Println("Starting nmap caller")
	var counter = 1
	var scanResultsFileName = "scan.xml"

	for {
		cmd := exec.Command("nmap", "-p", conf.NMAPPorts, "-oX", scanResultsFileName, conf.NMAPRange)
		log.Println("Init NMAP scan no:", counter)
		var out bytes.Buffer
		cmd.Stdout = &out
		err := cmd.Run()
		if err != nil {
			log.Println(err)
		}
		log.Println("Scan no.", counter, "complete")
		counter = counter + 1

		//read the xml file, convert to json and send via the websockets
		xmlfile, err := os.Open(scanResultsFileName)
		if err != nil {
			log.Println(err)
		}
		lock.Lock()
		nmapJSON, err = xj.Convert(xmlfile)
		lock.Unlock()
		if err != nil {
			log.Println(err)
		}
		log.Println("Writing to websockets")
		for c := range cons {
			err := c.WriteMessage(1, nmapJSON.Bytes())
			if err != nil {
				fmt.Printf("failed to write message! Cause: %v", err)
			}
		}
		<-time.After(time.Duration(conf.ScanInterval) * time.Second)
	}
}

func wsHandler(w http.ResponseWriter, r *http.Request) {
	log.Println("Ws request from:", r.Header.Get("Origin"))
	// log.Println("accepted from: http://" + r.Host)
	// if r.Header.Get("Origin") != "http://"+r.Host {
	// 	http.Error(w, "Origin not allowed", 403)
	// 	log.Println("Origin not allowed")
	// 	return
	// }
	conn, err := websocket.Upgrade(w, r, w.Header(), 0, 0)
	if err != nil {
		http.Error(w, "Could not open websocket connection", http.StatusBadRequest)
		log.Println("Upgrade error")
	}

	//add the connection to the pool for broadcast
	cons[conn] = true
	go echo(conn)
}

func main() {
	log.Println("Starting lan-monitor-server ver: " + version)

	//process the config
	//1st the config file is read and set parameters applied
	//2nd the command line parameters are interpreted,
	//if they are set they will overrule the config file
	//3rd if none of the above is applied the program reverts to the hardcoded defaults

	//defaults
	defaultConfigFileLocation := "/etc/lan-monitor.conf"
	var defaultHTTPPort = 8030
	var defaultNMAPRange = "192.168.0.2/24"
	var defaultNMAPPorts = "22,80"
	var defaultScanInterval = 120 //seconds

	displayVersion := flag.Bool("version", false, "Prints the version number")
	createExampleConfig := flag.Bool("config", false, "Writes the lan-monitor.json to local dir as example")
	cmdlineHTTPPort := flag.Int("port", defaultHTTPPort, "HTTP port for the webserver")
	cmdlineNMAPScanRange := flag.String("range", defaultNMAPRange, "The range NMAP should scan e.g. 192.168.1.1/24 it has to be nmap compatible")
	cmdlineScanInterval := flag.Int("scan-rate", defaultScanInterval, "The interval of the scans in seconds")
	configFileLocation := flag.String("config-file", defaultConfigFileLocation, "Location of the config file")
	cmdlinePorts := flag.String("scan-ports", defaultNMAPPorts, "The ports that will be scanned")
	flag.Parse()

	//try to read the configfile
	_, err := os.Stat(*configFileLocation)
	var config Config
	if err == nil {
		config = readConfig(*configFileLocation)
	} else {
		log.Println("Config file is missing - looked at:", *configFileLocation)
		log.Println("Reverting to commandline/defaults")
	}

	//if no range is defined in the config file
	if config.NMAPRange == "" {
		config.NMAPRange = *cmdlineNMAPScanRange
	}

	//if no port is defined in the config file
	if config.HTTPPort == 0 {
		config.HTTPPort = *cmdlineHTTPPort
	}

	//if no scan interval is defined in the config file
	if config.ScanInterval == 0 {
		config.ScanInterval = *cmdlineScanInterval
	}

	//if no ports to be scanned are defined
	if config.NMAPPorts == "" {
		config.NMAPPorts = *cmdlinePorts
	}

	log.Println("Config - range:", config.NMAPRange, "webserver port:", config.HTTPPort, "interval:", config.ScanInterval, "sec", "scan-ports", config.NMAPPorts)

	if *displayVersion == true {
		fmt.Println("Version: " + version)
		return
	}

	if *createExampleConfig == true {
		workingDir, _ := os.Getwd()
		fmt.Println("Config in JSON format written to:", workingDir)
		configJSON, _ := json.Marshal(config)
		err := ioutil.WriteFile("lan-monitor.json", configJSON, 0644)
		if err != nil {
			fmt.Println("Error writing demo config file")
		}
		return
	}

	workingDir, _ := os.Getwd()
	log.Println("Dir:" + workingDir)

	//init the scanning routine
	go callNMAP(config)

	//starting and configuring the webserver
	fs := http.FileServer(http.Dir(path.Join(workingDir, "www")))
	http.HandleFunc("/ws", wsHandler)
	http.Handle("/", fs)
	listenAddress := ":" + strconv.Itoa(config.HTTPPort)
	log.Fatal(http.ListenAndServe(listenAddress, nil))
}
